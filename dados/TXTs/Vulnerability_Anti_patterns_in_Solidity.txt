
Vulnerability anti-patterns in Solidity: Increasing
smart contracts security by reducing false alarms

Tommaso Oss 1 and Carlos E. Budde 1

University of Trento, Trento, Italy

Abstract Turing completeness has made Ethereum smart contracts at-
tractive to blockchain developers and attackers alike. To increase code
security, many tools can now spot most known vulnerabilities—at the
cost of production efficiency. Recent studies show false-positive ratios
over 99% in state-of-the-art technologies: this makes them impractical
for use in industry and have raised questions on the direction of academic
research. In this work we show how integrating and extending current
analyses is not only feasible, but also a next logical step in smart-contract
security. We propose light-weight static checks on the morphology and
dynamics of Solidity code, stemming from a developer-centric notion of
vulnerability, that we use to verify the output of other tools, flag poten-
tial false alarms, and suggest verifications. Besides technical details we
implemented an open-source prototype. For three top-10 vulnerabilities
it flags 324 warnings of other tools as false-positives, in 60 verified de-
duplicated smart contracts selected from the blockchain by the presence
of true (and false) vulnerabilities. This amounts to a 92%- to 100%-
reduction in the number of false-positives for these vulnerabilities.

1 Introduction

Since the practical solution of decentralised double-spending, the once academic
question of cryptocurrencies’ market viability now fuels one of the world’s fastest
developing technologies of the past 30 years [33]. Today, cryptocurrencies are
handled via digital ledgers known as blockchains, which deploy transactions in
distributed, unregulated, zero-trust “crypto markets”. Since its origins in 2008
[22], blockchains market size rose over $1 B by 2022, and passed the $1k B cap
in 2024, with prognostics of equivalent growth for the foreseeable future [6].

The first blockchain cryptocurrencies implemented cryptographically-protec-
ted ledgers to register transactions among parties/contracts, where the latter ex-
ist off-chain. Ethereum expanded this in 2014, turning smart contracts—written
in Turing-complete programming languages, mainly Solidity—into first-class cit-
izens of the blockchain. Thus, besides account ids and transaction amounts,
this blockchain encodes if-then-else clausal statements and loops for iterative
payments [2, 39]. This had two major consequences: first, Ethereum’s timeli-
ness and versatility made it rise in rankings to the top-3 blockchains in both
transactions-volume and market-cap, where it stands since 2015 [5, 6]; but also,
security errors in Solidity smart contracts are public and unfixable, waiting for


http://orcid.org/0009-0005-2071-9551
http://orcid.org/0000-0001-8807-1548


2 Oss & Budde

any malicious actor to exploit them. This combination led to a constant stream
of cyberattacks—worth millions of dollars each—that continues to this day [7].

Response by the community resulted in a plethora of security-enhancing ana-
lyses and tools, ranging from static and dynamic checks of program code and
bytecode, fuzz testing, and deep learning, to formal models of contracts inter-
action, and even game-theoretical analyses [1, 38, 20]. However and given the
stakes, most of the effort has been on the identification of potential vulner-
abilities. More precisely, when designing a tool to determine whether certain
portion of code is susceptible to malicious exploitation by a third party, true
positives and detection sensitivity are the focus. This has led to a bloating of
(false) alarms, where recent findings suggest false positive rates as high as 99.8%
for certain types of vulnerability [42]. Thus, while the current state-of-the-art in
Solidity smart contracts security can cover much of the vulnerability spectrum,
its feasibility to integrate in production environments has yet to be proven.

Research Question: Can current methods and tools that check the security
of Solidity smart contracts be used in modern code development?

We refine this research question into the following subquestions:
RQ1 Are there freely available tools capable off-the-shelf of finding security vul-

nerabilities in Ethereum smart contracts?
RQ2 What are the precision and specificity of these tools, to detect common

security vulnerabilities in Solidity?
RQ3 Can the precision (and specificity) of these tools be enhanced without com-

promising their ease of use?

Security vulnerabilities in smart contracts. We follow the standard ter-
minology from ict practitioners in which security incidents are set apart from
safety incidents, setting our research focus in the former. These involve an in-
terplay between attackers (A) and victims (V ) in detriment of the latter, via
vulnerabilities exploits and where A ̸= V [16]. We focus on vulnerabilities detect-
able in-chain, e.g. exploitable by A from existent code and regardless of actions
by V. While the canonical example in our setting is an illegitimate transfer of
funds from V to A, actions such as blocking functions in a contract that keep
V from claiming rightful funds are also covered [41]. In contrast, attacks such
as phishing or social engineering to gain illegitimate access to otherwise valid
functionality (are undetectable from code inspection and) fall out of scope. We
henceforth refer to the above as our definition of security vulnerability and high-
light its lack of formal rigour, which we discuss further in Sec. 2.2.

We answer subquestions RQ1 to RQ3 for security vulnerabilities in Solidity
smart contracts (ssc), via a structured procedure yielding four contributions:

1. We first gather ssc with different security vulnerabilities:
– we guide our choice of vulnerabilities by the owasp top-10 [25];
– we revise the literature for ssc vulnerable to the above, with verified

source code retrievable via official sources such as etherscan.io;

https://etherscan.io


Vulnerability anti-patterns in Solidity 3

– we iterate the two steps above, as we find that not all vulnerabilities have
verified, de-duplicated ssc with findable source code—we thus generate a
dataset of 60 verified Solidity smart contracts with available source code,
that the literature deems vulnerable to unchecked return value, reentrancy,
and timestamp dependence (20 contracts per vulnerability)—see Sec. 3;

2. For RQ1 we revise and select tools that detect vulnerabilities in ssc:
– we use a two-level filter, first selecting tools based on four usability criteria

that range from availability to output quality—we find and categorise 13
(out of 39) tools as eligible “off-the-shelf” to different degrees of usability;

– we then exercised the eligible tools in our test environment, selecting those
applicable to our contracts dataset, finally choosing 3 to experiment with.

3. We execute these tools in our dataset of 60 distinct ssc, to determine the
confusion matrix of each tool on for each vulnerability and answer RQ2:

– our dataset is divided into three sets of 20 contracts, each set targeting a
specific vulnerability and labelled with true- and false-positives;

– for each set we run all tools, generate the corresponding confusion matrix,
and compute precision and specificity, also measuring runtime.

4. We study the false positives above, identifying patterns incorrectly flagged
by more than one tool to interpret them as “anti-patterns” recognisable via
syntactic-checks, and thus propose an answer to RQ3:

– We characterise patterns in Solidity source code that resemble three types
of vulnerabilities but are in fact false-positives;

– We implement a prototypical foss tool (GPLv3, [24]) to recognise these
in code, and experiment in our dataset measuring its performance in pre-
cision, specificity, and runtime, showing the feasibility of our approach;

Data and Artifact Availability. We provide public access to all data and pro-
grams created and used in this work at doi 10.6084/m9.figshare.26121655 [24].
Outline Sec. 2 discusses related works after covering minimal background on
smart-contract security, including the concrete vulnerabilities under study. Then,
Sec. 3 describes our (necessarily manual) search for 60 ssc vulnerable to the
above, and Sec. 4 reviews foss tools that we assessed for the experimentation
done to answer RQ1 and RQ2. Reverse-engineering the outcomes of these tools
revealed the vulnerability anti-patterns that we introduce in Sec. 5 to answer
RQ3, and that we use for the confusion matrix results presented in Sec. 6. Finally,
after discussing limitations and extensions in Sec. 7, this work concludes in Sec. 8.

2 Background

2.1 Security of Solidity smart contracts

Blockchain. A blockchain is a distributed ledger of blocks (e.g. of transactions),
chained via cryptographic technologies that make each block unique based on

https://doi.org/10.6084/m9.figshare.26121655


4 Oss & Budde

the chain preceding it. Adding a new block is done via zero-trust consensus
algorithms executed by independent nodes, thus addressing deficiencies of cent-
ralised systems such as scalability limitations and single points of failure [9].
Ethereum. To form a chain, each block has a metadata header that minimally
includes a timestamp and a hash of the previous block. Depending on the imple-
mentation, the payload of a block (transaction) can have different types. Besides
transactions of its cryptocurrency (eth), the Ethereum blockchain allows the
payload to contain executable code. Therefore, this code called smart contract
can be executed by any node in the blockchain [43]—and once the result of its
execution enters the blockchain it becomes very hard or impossible to revert.

9 owner.send(msg.value/5);
10 if (invested[msg.sender] != 0){
11 address kashout = msg.sender;
12 uint256 getout = invested[msg.sender]*10/100

*(block.number-atBlock[msg.sender])/5900;
13 kashout.send(getout);
14 }

Code 1: Solidity snippet from EasyInvest10

Solidity. Code execution of Eth-
ereum smart contracts follows
the semantics of the Ethereum
Virtual Machine (evm [39]).
But the executed bytecode was
compiled from the programming
language in which the contract
was first written by humans. From all languages available, Solidity is officially
recommended by Ethereum and, by far, the most popular for smart contract
development [23]. Code 1 is a snippet containing Solidity builtin datatypes like
address (the address of a contract or wallet in the Ethereum blockchain), logical
branching with if, and the builtin function send (to transfer funds between
addresses)—see Appendix A for more examples. «Influenced by C++, Python,
and JavaScript», Solidity is Turing-complete and vulnerable to security bugs [31].
Vulnerabilities. Solidity smart contracts (ssc) can be attacked by malicious
parties, who exploit security vulnerabilities like in any stateful programming lan-
guage [28]. Vulnerabilities are classified, e.g. Denial of Service or integer overflow,
and statistics show the predominance of certain types both by the frequency with
which they are found, as well as the likelihood of being exploited [25]. The Open
Worldwide Application Security Project (owasp) compiles this information:
we study the following three vulnerability types, taken from the owasp top 10,
which match our security focus—see [25] or Appendix B for a complete list.
– Unchecked Return Value (urv): Solidity functions call, send, callcode,

and delegatecall return a Boolean stating the success of the operation, and
then contract execution continues. Regardless of the reason for a failure—e.g.
stack overflow or lack of gas†—attackers may exploit contracts whose logic
ignores the return value of these functions and just continue execution. Line 9
in Code 1 is one such example, where the execution of the if statement is
oblivious of the return value of the send, that it assumes successful. This type
of vulnerability is also known as Unchecked External Call.

– Reentrancy (ree): Reentrancy attacks leverage an insecure execution order
of instructions in a victim contract, that allows an attacker to repeatedly call

†«Ethereum requires users to pay for each step of the deployed contracts. The basic unit
of the fee is called gas. [ . . . ] initiators need to pay some gas for the execution» [38]

https://etherscan.io/address/0x0744a686c17480b457a4fbb743195bf2815ca2b8#code


Vulnerability anti-patterns in Solidity 5

a function before it completes execution. The classic example is an invocation
to call, to transfer eth to the user (attacker), before updating its balance in
the contract. This has been used to siphon all eth from a victim contract few
transactions, making reentrancy the most feared Solidity vulnerability [41, 42].

– Timestamp Dependence (td): Some ssc use the block timestamp (con-
stants block.timestamp or now) to implement time-dependent logic such as
locking funds for certain duration or seeding randomness for fairness. But
the Ethereum protocol allows the timestamp of a block to be affected—in
at bounded but flexible time range—by the node executing it [39, 40]. This
makes the timestamp manipulable, which an attacker can exploit e.g. when it
is used to control the transfer of cryptocurrency [40].

2.2 Related work

ssc security has been a hot topic for a decade. Best-practices to write secure code
are available for developers, from sources such as the Ethereum’s Solidity manual
and the owasp vulnerabilities list [31, 25]. From a theoretical viewpoint, game
theory has been used to find Stackelberg- or Nash-equilibria conditions based on
(nodes) mining incentives and blockchain consensus protocols [20]. Instead, we
revise the state-of-the-art for vulnerabilities detection from ssc code [38].

ssc vulnerabilities. Regarding definitions of security vulnerability, we find
human-readable lists or taxonomies such as owasp and Chen et al. (2021) [4],
or works that provide source- or byte-code definitions to identify vulnerable code
fragments in practice—most of which result in too many fp [10, 14, 27, 42]. We
find no formal definition for models with well-defined semantics—Time Auto-
mata, mdps, etc.—actionable with formal tools support for verification.

While our definition in Sec. 1 takes a step in that direction, our focus is
to help developers produce code not exploitable by 3rd parties. This removes
the contract owner from the attackers (A in page 2), so code exploitable by
hardcoded addresses are deemed fp. Such “exploits” are akin to common (le-
gitimate) safety functions like selfdestruct that the owner can use to withdraw
funds from the contract address. Still, as restated in Sec. 8, the authors believe
that the blockchain community would benefit from a formal definition of security
vulnerability, actionable with modern model checkers with check times < 1 s.

Vulnerability detection. Most of the scientific literature studies how to in-
crease detection sensitivity of ssc vulnerabilities from byte- or source-code. In
surveys [4, 38] we also find eight works that are closer to our research questions,
in that they seek to increase (or at least measure) detection specificity. We dis-
cuss them in Table 1 and highlight that [42, 19] served as main inspiration to
this work: we propose generalisations that extend several of those principles to
more vulnerabilities, minding runtime efficiency as per RQ3.



6 Oss & Budde

Table 1: Related works that measure or reduce fp ratio

Work Points in common Differences
Practical fp code pattern recognition for reentrancy

[41]
[42]

Study the limitations of state-of-the-
art tools to find reentrancy, proposing
fp code patterns. [41] further intro-
duces a symbolic-execution tool that
mitigates reentrancy fp via filters
based on these patterns.

We cover two vulnerabilities besides
reentrancy, for which we too propose
code patterns that we successfully used
to detect fp. We further target low
(check) runtimes for integration in
production environments (RQ3).

Sound symbolic execution with practical comparisons

[3]

Analyses control-flow graphs, looking
for paths involving monetary transac-
tions that violate security properties.
This is a sound approach to find vul-
nerabilities that reduces the number
of fp w.r.t. other tools (see Sec. 4).

The use of symbolic execution (a) pro-
duces paths that the user has to check
to re-interpret as code, and (b) has
limited coverage e.g. for loops. We per-
form static checks that point directly
at code lines in an ssc.

Existent tools efficacy: flagged (vulnerable) vs. exploited code

[10]
[19]
[27]

Study the efficacy of existent tools
to find ssc vulnerabilities: they re-
port high fp ratios and a mismatch
between flagged code and exploited
code (the latter being as low as 1%
of the former for some vuln.). [19,
Fig. 5] suggests fp code patterns.

We are not only interested in studying
other tools, but also in implementing
the identified code patterns into a pro-
totypical tool, to run experiments and
measure the efficiency with which they
can detect fp.

Synthetic tool benchmark frameworks, including bug-injection

[12]
[14]

Propose benchmarking approaches
for ssc security tools: the SmartBugs
execution framework, and SolidiFI for
bug-injection including several types
of security vulnerabilities.

We do not target large synthetic data-
sets, but use other tools’ results to
identify fp code patterns that we im-
plement and test. We work on verified
ssc, deployed in Ethereum and la-
belled by humans as vulnerable.

3 Finding vulnerable Solidity smart contracts

Tools of the trade. Sec. 2 shows a well-known bloating in the number of code
fragments (and contracts) flagged as vulnerable by state-of-the-art tools [10,
19, 42]. While this has been interpreted as evidence of a misalignment between
academia and industry, the thesis of this work is that current technologies can
be easily and efficiently adapted to reduce the number of false positives (fp).

By easily we mean that code inspection can reveal fp patterns for each
vulnerability type, that can be added to current and future software tools to
reduce their fp ratio. This is linked to the definition of security vulnerability,
which (can be tuned and) for us considers “self-harm” as fp, since it is now
known that it does not cause exploits—see sections 1 and 2.2, and [27, 19].

By efficiently we mean that static checks—or other light-weight verification
approach—should suffice to spot most fp with minor runtime impact. Ideally,
these checks should be fast enough to allow developers to perform their regular



Vulnerability anti-patterns in Solidity 7

tasks, while guiding their attention to code fragments that require a security-
perspective revision. As we show in Sec. 6, current state-of-the-art tools seem to
go in either of these directions: speed or else precision. By reducing the number
of fp with fast runtime we aim for faster precision.
A curated dataset of labelled ssc source code. Two consequences of the
above are: (a) from the works that list thousands of vulnerable ssc, a very
low percentage contains contracts actually vulnerable; and (b) to distinguish
true vulnerable patterns from false ones—e.g. by human inspection—a dataset
of ssc with true security vulnerabilities must be built. Also (c) most tools
work with bytecode—see Sec. 4—so building a varied dataset of ssc source
code examples truly affected by specific vulnerabilities is non-trivial. This means
that practical studies like ours, that target the end developer, cannot easily
bootstrap from existent datasets. Our research requires ssc deployed in the
Ethereum blockchain—to operate on real tp as opposed to the typically easier-
to-detect injected tp—with de-duplicated verified source code in etherscan.io,
and (ideally human-verified) labels of security vulnerabilities.

Table 2: Curated dataset
Vulnerability #cntr. tp fp
Unchk. Ret. Val. 20 5 23
Reentrancy 20 3 79
Timestamp Dep. 20 5 67

Total 60 13 169

Therefore, we performed a systematic search
on existent datasets for ssc matching this cri-
teria. Per vulnerability in scope we selected 20
contracts, with verified source code available in
the blockchain, among which at least three con-
tain a vulnerability matching our definition. To
reduce bias, tp and fp labelling was performed
for ten contracts per vulnerability by one of the
authors, and verified by the other. Specifically for urv and td all contracts were
taken from [32]—which contains automatic-tool labels only—while for ree we
also resorted to [42]—which has human labels whose tp match with ours.

Table 2 summarises our dataset, which we make publicly available in [24].

4 FOSS tools for Solidity security

To answer RQ1 we reviewed popular tools from online resources and surveys [30,
38], to select those expected to be accessible to the standard developer. We deem
a tool usable off-the-shelf if it is publicly available and easy to setup, execute,
and understand its output. We make our assessment systematic in Table 3, which
defines four criteria divided in levels: a green cell marked ✓ indicates a criterion
level eligible as off-the-shelf; red cells marked × indicate the opposite‡. Thus,
eligible tools must have an availability level ⩽ 1, installation level ⩽ 3, and
usage-input and usage-output levels ⩽ 2.

Applying this criteria to the 39 tools found in the literature produces the
results shown in Table 4, which resulted in 13 eligible tools. From those we further
‡This is inspired in the artifact badging system of cs conferences, where e.g. the acm
Available badge is equivalent to our availability lvl. 1, the Functional badge requires
all criteria to be at most lvl. 2, and for the Reusable badge all levels must be 1.

https://etherscan.io


8 Oss & Budde

Table 3: Criteria for selecting tools as eligible for use “off-the-shelf”
Level C1: availability C2: installation C3: usage input C4: usage output

1 ✓ Tool publicly
available, with
download link for
unrestricted use

✓ Simple setup
(⩽ 5 commands)
via provided in-
structions

✓ Usage commands
provided and well
explained, succeeds
on first try

✓ Output simple
and clear, under-
standable at first
glimpse

2 × Tool proposed,
but not public or
only upon contact
with authors

✓ Complex setup
(> 5 commands)
via provided in-
structions

✓ Usage commands
provided but details
missing, takes some
trial and error

✓ Output too verb-
ose or complex, but
results of analysis
are findable

3 × No tool: only
a theoretical ap-
proach or al-
gorithm is pro-
posed

✓ Many setup
processes proposed,
only some work

× Usage commands
not provided (or only
some examples, hard
to generalise)

× Output shows
errors, hard or im-
possible to obtain
results of analysis

4/5 × (4) Setup only
possible via ex-
ternal web search,
or (5) not possible

filter out the tools that cannot process some of the vulnerabilities targeted by our
study, and that are unable to process more than 30% of our curated dataset of
ssc (e.g. by incompatibility of the Solidity version)—full details on this second-
level filter are in Appendix C. We highlight that, albeit extensive, our search
was not necessarily exhaustive—see Sec. 8 for a discussion on this.

The final result were three tools that we used for experimentation in this
work: Slither [13], Mythril [30], and Remix [34]. Remix is the official ide for
Solidity, developed and maintained by Ethereum. While the other tools were
specifically designed for security checking, Remix provides a much broader de-
velopment functionality such as autocompletion and linting. Our use of Remix
is however limited to security checks, for which we considered both the compil-
ation warnings displayed on the editor’s gutter, as well as the alerts generated
by the Solidity Analyzers plugin. In turn, this plugin can integrate three tools
for code analysis: Remix Analysis (which covers the security category and we
select), Solhint (a Solidity linter), and Slither (which we study independently).

RQ1 has a positive answer: Table 4 characterises 13 tools usable off-the-shelf.

5 Vulnerability anti-patterns

The vulnerabilities from Sec. 2.1 can, in part, be automatically detected in ssc
using security tools like Slither, Mythril, and Remix. This section proposes simple
code patterns which, when matched by a “vulnerability”, suggests that it is in
fact a fp. These results provide a (theoretical) positive answer to RQ3, and were
matured mainly by reverse-engineering the outcomes of our experiments—the
rationale and some code examples are given in Appendix D. Still, we introduce
these patterns (first) here to ease the interpretation of results in Secs. 6 and 7.



Vulnerability anti-patterns in Solidity 9

Table 4: Evaluation of tools usable “off-the-shelf” by the criteria from Table 3
Vuln. detect. CriteriaTool urv ree td C1 C2 C3 C4 Elig.

AChecker 1 1 1 1 Yes
ConFuzzius ✓ ✓ ✓ 1 3 2 2 Yes
ContractFuzzer ✓ ✓ ✓ 1 5 - - No
ContractWard ✓ ✓ ✓ 2 - - - No
EasyFlow 1 5 - - No
Echidna 1 1 1 1 Yes
EtherSolve ✓ 1 1 1 2 Yes
Ethlint ✓ ✓ 1 1 2 1 Yes
eThor ✓ 1 1 2 3 No
ExGen ✓ 1 5 - - No
Gasper 2 - - - No
Halmos ? ? ? 1 1 3 - No
Harvey ✓ ✓ 1 5 - - No
Horstify ✓ ✓ ✓ 1 5 - - No
MadMax 1 5 - - No
Maian 1 5 - - No
Manticore ? ? ? 1 5 - - No
Medusa 1 1 2 1 Yes
Mythril ✓ ✓ ✓ 1 3 2 1 Yes

Vuln. detect. CriteriaTool urv ree td C1 C2 C3 C4 Elig.

Osiris ✓ ✓ ✓ 1 3 1 2 Yes
Oyente ✓ ✓ ✓ 1 3 1 1 Yes
ReGuard ✓ 2 - - - No
Remix ✓ ✓ ✓ 1 1 1 1 Yes
S-Gram ? ? ? 2 - - - No
Securify ✓ ✓ ✓ 1 4 1 1 No
Seraph ✓ 2 - - - No
Sereum ✓ 3 - - - No
sFuzz ✓ ✓ ✓ 1 2 3 - No
Slither ✓ ✓ ✓ 1 1 1 2 Yes
SmartCheck ✓ ✓ ✓ 1 1 1 1 Yes
SmartCopy ✓ ✓ ✓ 2 - - - No
SmartShield ✓ ✓ 2 - - - No
SoliDetector ✓ ✓ ✓ 2 - - - No
Solscan ✓ ✓ ✓ 1 1 1 1 Yes
Vandal ✓ ✓ 1 5 - - No
VeriSmart ? ? ? 1 5 - - No
Vultron ✓ ✓ 1 5 - - No
WANA ✓ ✓ ✓ 1 1 1 3 No
Zeus ✓ ✓ 1 5 - - No

5.1 Unchecked Return Value

Studying the fp of the tools tested we find five vulnerability “anti-patterns”
that can be deemed false alarms. Matching any of these patterns indicates a fp:
1. If the visibility of the function is private or internal, and is unreachable

from public or external functions free of restrictions (e.g. modifiers), they
are inaccessible to attackers.

2. Similar to the above, if the potentially vulnerable function has modifiers that
restrict its access to e.g. only the contract owner, it is inaccessible to attackers.

3. If the flagged function contains restrictions that make it reachable only through
the validation of special conditions (typically require), user access is restric-
ted; if it matches a hardcoded address then it is inaccessible to attackers.

4. If the recipient address is the caller (viz. the address on which the call to
transfer cryptocurrency is made), a failure can only result in self-harm: failed
transfer cryptocurrency to themselves via call or send, or self-defined function
via delegatecall or callcode. By our definition of vulnerability this is a fp.

5. If the function is the last one in the function, no harmful subsequent instruc-
tions can be executed. Matches of urv in this case are a fp.

5.2 Reentrancy

Experiments carried out in our curated dataset, in conjunction with the insights
given in [42], gave rise to the following six ree anti-patterns:
1–3. These patterns are the same as those listed for urv in Sec. 5.1, which for

ree also match the so-called “Permission Control Group” from [42].



10 Oss & Budde

4. If the address at which the external call is initialised is a hardcoded address,
it is beyond the control of the attacker. This means that a reentrancy exploit
cannot be launched.

5. If no state variable is modified after the external call (e.g. the balance of a
user) and before function termination, then reentrancy is not possible.

6. If the msg.value to transfer is less than or equal to the amount of cryptocur-
rency received by the vulnerable function, reentrancy would at best increase
rather than decrease funds at the victim contract, until the attacker runs out
of funds—this matches the “Special Transfer Value” from [42].

5.3 Timestamp Dependence
This vulnerability differs from the other two in that the attacker is not a regular
ssc user calling the contract, but rather a miner that executes the contract
in a transaction to be added to a block. Notwithstanding, code analysis can
still effectively find vulnerable contracts, and it can also yield false positives. In
particular we found one vulnerability anti-patter for td:
1. If the timestamp is used (directly or via variables) exclusively to verify pres-

ence in a time interval greater than 20 seconds, i.e. by a value comparison to
constants or other variables, then by the “15-seconds rule” [40] the likelihood
of an attack is extremely low if not altogether impossible.

6 Empirical experiments on FP reduction
This section demonstrates our pattern-recognition approach, via practical ex-
periments on our curated dataset of 60 ssc from the Ethereum blockchain.

As control we run them via the three selected tools (Slither, Mythril, and
Remix) to find urv, ree, and td vulnerabilities, creating confusion matrices
and measuring execution runtimes. As test we implemented a prototypical tool,
originally designed to refine the vulnerabilities found by these tools, but that
here we execute standalone. All our results and scripts are in a public artifact
accessible at doi 10.6084/m9.figshare.26121655 [24].

6.1 The Detecti tool https://github.com/Oss28/Detecti

We developed a Python tool, Detecti (GPLv3), that runs static checks to
identify the patterns presented in Secs. 5.1 to 5.3. It uses Surya [17] to parse the
code of an input ssc and identify potentially offending lines related to urv,
ree, or td. Detecti can also function as semi-automatic wizard, offering the
user the option to perform the distinct checks mentioned in Sec. 5.

Technically, for urv it initially considers all instructions with the call, send,
delegatecall, or callcode functions and an unused return value, deeming them
tp if none of the patterns from Sec. 5.1 are matched. An analogous approach is
followed for ree, evaluating functions containing call or instructions directly
executing functions from other contracts. For td it considers the instructions
that can (directly or via variables) use the block timestamp as indicated.

https://doi.org/10.6084/m9.figshare.26121655
https://github.com/Oss28/Detecti
https://github.com/Oss28/Detecti


Vulnerability anti-patterns in Solidity 11

6.2 Results from smart contracts verifications

Figs. 1a to 1c show the outcomes of execution of the tools in our dataset. There
is one chart per vulnerability, and each is divided into true- and false-positives
(above the dotted line), and true- and false-negatives (resp. below). The false
predictions of a tool are in darker colours. The absolute value of a bar indicates
the case count. For instance, the Ground Truth (gt, taken from our dataset)
for urv in Fig. 1a reports 5 tp and 23 tn. Note that in Sec. 3 we called the
latter fp; here we call them tn to highlight that they are code lines of interest
for the respective vulnerability, that cannot be exploited.

(a) urv

Ground

Truth

Slither Mythril Remix Detecti
-30

-20

-10

0

10

20

30

11.5s 16658s 400s 12.3s

+

-

(b) ree

Ground

Truth

Slither Mythril Remix Detecti
-100
-80
-60
-40
-20
0

20
40
60
80

+

-

12.1s 35779s 400s 16.1s

(c) td

Ground

Truth

Slither Mythril Remix Detecti
-80

-60

-40

-20

0

20

40

60

80

12.5s 55655s 400s 13.8s

+

-

Miss
TN
FN

TP
FP

Figure 1: Confusion matrices for vulnerabilities detected in our dataset

The bars corresponding to the tools Slither through Detecti count one fp
for each line flagged in the contract that is a tn according to the gt, and
conversely for fn and tp. So for instance Mythril in Fig. 1a indicates 14 fp
(lines marked as vulnerable that are tn in the gt), 5 tp (vulnerable lines that
coincide with the gt), 1 fn (lines marked as safe that are tp in the gt), and 9
tn (safe lines that coincide with the gt). Appendix E shows individual results.

Cases missed by a tool, while essentially negatives and counted as such in
Fig. 1, are not lines of code analysed but rather blind spots. They indicate
runtime errors (for Slither, Mythril, and Remix), or lines that we are aware that
the pattern-recognition implemented in Detecti is currently not catching.

Table 5: Runtimes (s)

Vuln. Slither Detecti Mythril

urv 11.5 12.3 16658
ree 12.1 16.1 35779
td 12.5 13.8 55655

Finally, the numbers above each tool name are
the aggregated runtime in seconds that it took to
execute it in the 20 contracts of a vulnerability in
a standard laptop. These were measured with the
time unix command—we show them enlarged in
Table 5—except for Remix. As described in Sec. 4,
Remix vulnerability detection cannot be done in
batch: being an ide we must use its gui for each contract separately. Therefore
the 400 s reported are just an estimation, that count 20 seconds per contract to
load it in the ide and launch the corresponding analysis tasks.
urv results. Fig. 1a shows identical signatures of Slither and Remix for Un-
checked Return Value. These tools deem vulnerable every instruction where the



12 Oss & Budde

values of the relevant functions are not captured by a variable or used in a guard.
In the 20 urv contracts of our dataset this heuristic matches all (5) tp but also
21 fp, resulting in precision 5/26 = 0.19, and specificity 2/23 ≈ 0.09. Mythril did
better, possibly thanks to its taint-analysis capabilities, with precision 4/18 =
0.22, and specificity 9/23 ≈ 0.39 with 9 tn identified. In contrast, by using the
patterns from Sec. 5.1 Detecti is able to identify all the fp as such, maxing
out both precision and specificity. However, the tp of SmartBlockchainPro was
incorrectly assessed as a fp, which results in a lower sensitivity.
ree results. Fig. 1b tells a somewhat similar story for Reentrancy, where
Slither and Remix flag as vulnerable every external call function listed in Sec. 5.2
for which a “change of state” follows through. However, these tools consider
events emission as a state change, contrary to the Solidity specification [31]. As
a result, Slither had 52 fp but no fn, and Remix 34 fp and 2 fn (this omits
four contracts where Remix failed with an error, amounting to 21 missed cases),
yielding precisions resp. 3/55 ≈ 0.05 and 1/35 ≈ 0.03, and specificities 27/79 ≈ 0.34
and 24/58 ≈ 0.41. Mythril showed better performance, producing 48 fp and 1 fn
(precision 2/30 ≈ 0.07 and specificity 48/76 ≈ 0.63) and failing to analyze only the
Dice contract. In contrast, using the patterns from Sec. 5.2 Detecti confirmed
as negative every tn analysed, maxing out specificity. Precision however was
null, as Detecti currently only consider calls within a single function and it
missed (i.e. did not analyse the source code) of the three tp. This limitation—
unrelated to code pattern recognition—is discussed in ??.
td results. For Timestamp Dependence the approach of Remix is simple: every
use of block.timestamp is vulnerable. This results in precision and specificity of
5/72 ≈ 0.07 and 0 resp. Instead, Slither flags “only” 60 fp and correctly identifies
7 cases as tn, for a precision and specificity of 5/65 ≈ 0.08 and 7/67 ≈ 0.10
resp. As before, Mythril comes the better tool with 44 fp but also 4 fn, for
a precision and specificity of 23/57 ≈ 0.40 and 1/45 ≈ 0.02 resp. Also as before,
Detecti improves on all the previous values with one fp and another fn, for
a precision and specificity of 4/5 ≈ 0.80 and 61/62 ≈ 0.98 resp. These results
include the same technical limitation mentioned for ree: for this vulnerability,
Detecti did not inspect inter-function calls that was relevant for td, omitting
the analysis of code that contained 5 instructions including four fp and one tp.

Table 6: Precision and specificity of
the tools in our experiments

Slither Mythril Remix Detecti
Vuln. Pr Sp Pr Sp Pr Sp Pr Sp
urv .19 .09 .22 .39 .19 .09 1 1
ree .05 .34 .07 .63 .03 .41 0 1
td .08 .10 .40 .02 .07 0 .80 .98

Table 6 summarises these results,
showing a relatively poor performance
of the selected tools—in terms of preci-
sion and specificity–to analyse our cur-
ated dataset for security vulnerabilities.
This was already apparent by looking
at Figs. 1a to 1c, and noting the high
amounts of fp for all vulnerabilities, co-
inciding with the findings of the latest
literature also for the cases of the urv and td vulnerabilities.

RQ2 is answered—with a low performance of available tools—in Table 6.



Vulnerability anti-patterns in Solidity 13

For our final research question we first observe the performance in terms of
runtime of existent tools, as shown in Fig. 1 and table 5. The time required to
run a security analysis in an already loaded contract, by both Slither and Remix,
was always less than 5 seconds. This suggest that these tools could very likely
be used in a production environment. On the other side of the spectrum we have
Mythril, which consistently overcome the other tools in all cases of precision and
specificity, but also required an average of 40 minutes to analyse each contract,
with a minimum of 3 minutes and a maximum of about 3.5 hours.

The approach we took of identifying vulnerability-specific code patterns,
mapping them to semantic use, exploits light-weight syntactic verifications in
a non-general environment. Since our checks (implemented in Detecti) are on
static source code, the achieved speed is comparable to that of Slither in all
cases. At the same time, for these vulnerabilities and in our dataset, the quality
of the vulnerability-detection outcomes shows substantial improvements even in
comparison to Mythril, and despite some technical and semantic limitations that
we discuss in depth in Sec. 7.

RQ3 has a positive answer, demonstrated by Detecti in Fig. 1 and table 6.

7 Discussion

7.1 General performance of the tools

While Mythril was the tool to produce most fn, it was also the best performing
tool in terms of (low) fp rate and overall specificity. This is likely attributable to
its dynamic-analysis approach, which result in a correct but incomplete analysis
of the possible execution paths in the contract. Unchecked vulnerable paths
cannot be flagged, yielding false negatives.

Oppositely, the static analysers Remix and Slither can only check syntax,
and take the conservative approach of flagging many suspicious instructions as
vulnerable, leaving the final decision to the programmer. This unavoidably pro-
duces a very high number of false positives, i.e. 92% of the positives produced
by these tools in our experiments are actually false positives. Our conjecture is
that so many (false) alarms can weary the developer, who would then disregard
most warnings and having a negative net effect in smart contract security.

We highlight how such high fp rate affects Remix, commended for its ability
to detect true positives, but without equivalent treatment of precision indices
[42]. Our experiments reveal that between Slither and Remix, the former has a
(slightly) better general performance as it generates a few less false alarms.

More importantly, our results with Detecti suggest that static analyses can
indeed be enhanced to remediate a non-trivial amount of fp, without comprom-
ising the responsiveness of the tool (as it happened e.g. with Mythril). It could
discern 95% false positives out of the positive results given by the other tools.
Thus, as a proof of concept, Detecti performed well to improve the specificity
of existent tools: we study each vulnerability type next.



14 Oss & Budde

7.2 Threats to validity and technical limitations of Detecti

General technical limitations of the prototype. We examine the limit-
ations stemming from the tests conducted in Sec. 6, as well as the technical
implementation choices of the Detecti prototype.
– The first limitation affects all vulnerabilities, and involves the tool’s inability

to display the names of complex variables in a humanly understandable format
(see our artifact [24]). In such instances, the output contains a placeholder
instead of the variable name, with the option to print the variable’s dictionary
identification by activating the verbose option.

– Another technical limitation is when default functions of Solidity such as
send,call,transfer are overloaded in the contract code. The tool will not
detect these alterations and might inaccurately assess uses as tp. For example
for urv, the current implementation of Detecti assumes that send, call,
callcode, and delegatecall are not overloaded. While we have not found a
single ssc where these functions had been overloaded, if they are and e.g. the
overloaded send raises an exception instead of returning a false upon failure,
then a urv vulnerability cannot occur for this function.

– Also and as mentioned in Sec. 6.2, the current implementation of Detecti
performs analyses local to a function scope. This was the cause of the missed
vulnerabilities for ree and td in Figs. 1b and 1c. While the solution is
apparent, namely creating and traversing the whole control flow graph, this
would most likely result in long checking times that defeat a main driver
of this research. We are currently exploring partial solutions, that include a
bounded number of functions hops which could cover most typical cases.

Improvements for urv analysis. Identification of false-positives for this
vulnerability type could be further improved as follows
– Check whether the analyzed code is in the ssc constructor: this would label

it as fp because the constructor is executed only at contract deployment, and
its runtime bytecode will not appear in the blockchain.

– Refining the criteria for the verification conditions and modifiers. The current
prototype assumes that conditions and modifiers invariably restrict access.
While this is the case in all contracts found so far, it cannot be guaranteed
(just as in the case of function overloading discussed above) without further
code analysis. We expect that simple conditions such as keyword matches
could be cheap and mostly effective—for a sound analysis the only solution
may be smt solving à la Mythril.

– As mentioned above, the function-scope search of Detecti will fail if the
vulnerability is distributed among functions. The fn example is trivial: a
function fA which contains a urv but has private visibility. If fA is called
from another—public—function fB , and state modification occurs in fB , then
the contract should be flagged as vulnerable.

Improvements for ree analysis. fp identification could improve by:



Vulnerability anti-patterns in Solidity 15

– The same cases mentioned for urv about ssc constructor, inter-function
calls, and conditions and modifiers. As a special case, “cross-contract reen-
trancy” is a variant of ree that Detecti cannot currently detect.

– Builtin Solidity functions like send and transfer are usually deemed fp for
ree due to the 2300 forwarded gas limit. It could be possible to overload
e.g. send such that when the fallback function is called it would forward all
remaining gas, enabling a reentrancy attack. A mitigation to cover such cases
could check that calls to builtin functions involve the expected parameters.

Improvements for td analysis. fp identification could improve by:
– The same cases mentioned above about constructors and inter-function calls.
– The current version of the tool does not go beyond the mechanisms to ap-

ply the “15-second Rule”.∗ Detecti identifies the scenario of time-interval
verification, and heuristically attempts to establish whether the integrity of
the operation of the contract cannot be compromised by the feasible manip-
ulation of the timestamp. While this is effective to spot fp, a taint-analysis
could extend the approach even to instructions that use the timestamp in
operations related to values of cryptocurrency transfers.

– On a similar note, even if a potential dangerous td is found, the peculiarities
of this vulnerability make an impact analysis feasible and useful. For a simple
example, fuzzy testing could be used to experiment with the magnitude of the
manipulations of the timestamp on the amount of cryptocurrency transferred.

8 Conclusions

This work extends the state-of-the-art in security revisions for Ethereum smart
contracts written in Solidity. In our literature search, we were able to find 13
foss tools (including Slither, Mythril, and Remix) that can be used off-the-shelf
for Solidity security enhancement, answering RQ1 positively.

We exercised the three tools mentioned above on 60 smart contracts taken
from the Ethereum blockchain, which we manually inspected and labelled to
determine the presence of three types of vulnerabilities selected from the owasp
top 10: Unchecked Return Value, Reentrancy, and Timestamp Dependency.

We exercised the tools to detect vulnerabilities in this dataset: comparing
their diagnoses with our ground truth we found that 92% of the vulnerabilities
flagged by the tools are in fact false positives. This gives a discouraging answer
to RQ2, as we conjecture that producing too-high a volume false positives can
be more detrimental to overall company-efficiency and contract security (tired
eyes will not pay attention to every “useless” warning).

From these results and via literature research, most notably [38, 42], we pro-
posed static analyses concerning our selected vulnerabilities, whose observation
can increase the confidence with which specific lines or instructions are deemed
∗The 15-seconds rule is an approximative estimator of the exploitability of a time-
based vulnerability, which states that «If the scale of your time-dependent event can
vary by 15 seconds and maintain integrity, it is safe to use a block.timestamp» [40]



16 Oss & Budde

potentially vulnerable, by flagging patterns related to false security vulnerability
alarms. This can improve practical usability of security tools via a lightweight
pattern-recognition (static) approach.

The above gives a positive theoretical answer to RQ3. We further added an
empirical demonstration by implementing a Python tool, Detecti, and execut-
ing it on the same dataset as the other tools used for experimentation. The
outcomes were that Detecti could detect most of the false positives generated
by three state-of-the-art tools—including the official ide of Solidity, Remix.

These results take special relevance in the face or recent findings like [42],
which could have suggested a misdirection of academic endeavours regarding
security enhancements of smart contracts. We believe that our results, which
leverage the efforts of much previous work, show how a proper integration of
research in the field can provide much better practical performance for use in
production environments.

Future work

While we strived to cover most available foss tools for Solidity security, the
fast pace of the field makes it infeasible to guarantee complete coverage. Many
tools are deployed as a successful proof-of-concept whose maintenance stops after
a few years (e.g. Oyente); others are currently under development or require
non-trivial setups, essentially misaligning with our RQ1. Still, we believe that
a comprehensive experimental analysis of tools, under a well-defined but laxer
selection criteria, would benefit the community.

In particular this would necessitate a catalogue or taxonomy of security vul-
nerabilities in smart contracts, against which the tools would be tested. For the
current work we resorted to well-known and official but “informal” resources
such as the OWASP ranking [25]. A hardened catalogue of vulnerabilities, e.g.
with examples of contract snippets and descriptions of the exploits, is a sine qua
non for a more formal and comprehensive approach to the task.

Besides a taxonomy of vulnerabilities, a dataset of labelled vulnerable ssc,
real in the sense that they exist in the Ethereum blockchain, are fundamental
for the generation of consistent benchmarks. We contributed to this effort with
our dataset, and are working to include further contracts in the future.

Moreover and as stated in Secs. 1 and 2.2, the community would greatly
benefit from a formal definition of security vulnerability, ideally adaptable to
the different variants of security interpretation e.g. as listed in works like [4].

Finally, regarding Detecti, we have had the opportunity in previous sec-
tions to discuss how it would be possible to improve and complete the detec-
tion of patterns currently being considered. But it is worth mentioning that
another strength of Detecti is its modularity, which we hope will encourage
other researchers to contribute and improve this tool, implementing new pattern
detection, and considering new types of vulnerabilities.

Data availability. We provide public access to all data and programs created and used
in this work at doi 10.6084/m9.figshare.26121655 [24].

https://doi.org/10.6084/m9.figshare.26121655


Vulnerability anti-patterns in Solidity 17

Funding. This work was funded by the European Union under the MSCA grant
101067199 (ProSVED), and NextGenerationEU projects D53D23008400006 (Smarti-
tude) under MUR PRIN 2022, and PE00000014 (SERICS) under MUR PNRR. Views
and opinions expressed are those of the author(s) only and do not necessarily reflect
those of the European Union or The European Research Executive Agency. Neither
the European Union nor the granting authority can be held responsible for them.

References

1. Bartoletti, M., Lande, S., Murgia, M., Zunino, R.: Verifying liquidity of recursive
Bitcoin contracts. Logical Methods in Computer Science 18(1) (2022). https://doi.
org/10.46298/lmcs-18(1:22)2022

2. Buterin, V.: Ethereum: A next-generation smart contract and decentral-
ized application platform (2014), https://ethereum.org/content/whitepaper/
whitepaper-pdf/Ethereum_Whitepaper_-_Buterin_2014.pdf

3. Chang, J., Gao, B., Xiao, H., Sun, J., Cai, Y., Yang, Z.: sCompile: Critical Path
Identification and Analysis for Smart Contracts, pp. 286–304 (10 2019). https:
//doi.org/10.1007/978-3-030-32409-4_18

4. Chen, H., Pendleton, M., Njilla, L., Xu, S.: A survey on Ethereum systems secur-
ity: Vulnerabilities, attacks, and defenses. ACM Comput. Surv. 53(3), 67:1–67:43
(2021). https://doi.org/10.1145/3391195

5. Coinmarketcap (2024), https://coinmarketcap.com/
6. crypto.com (2024), https://crypto.com/price
7. Hacks to cryptocurrencies in 2024 (2024), https://www.immunebytes.com/blog/

list-of-largest-crypto-hacks-in-2024/
8. Crytic: Crytic/medusa: Parallelized, coverage-guided, mutational solidity smart

contract fuzzing, powered by go-ethereum, https://github.com/crytic/medusa
9. Di Pierro, M.: What is the blockchain? Computing in Science & Engineering 19(5),

92–95 (2017). https://doi.org/10.1109/MCSE.2017.3421554
10. Dia, B., Ivaki, N., Laranjeiro, N.: An empirical evaluation of the effectiveness of

smart contract verification tools. In: PRDC. pp. 17–26 (2021). https://doi.org/10.
1109/PRDC53464.2021.00013

11. duaraghav8: Duaraghav8/ethlint: (formerly solium) code quality & security linter
for solidity, https://github.com/duaraghav8/Ethlint

12. Durieux, T., Ferreira, J.F., Abreu, R., Cruz, P.: Empirical review of automated
analysis tools on 47,587 Ethereum smart contracts. In: ICSE. pp. 530–541. ACM
(2020). https://doi.org/10.1145/3377811.3380364

13. Feist, J., Grieco, G., Groce, A.: Slither: A static analysis framework for smart
contracts. In: WETSEB (2019). https://doi.org/10.1109/WETSEB.2019.00008

14. Ghaleb, A., Pattabiraman, K.: How effective are smart contract analysis tools?
Evaluating smart contract static analysis tools using bug injection. In: ISSTA. pp.
415–427. ACM (2020). https://doi.org/10.1145/3395363.3397385

15. Ghaleb, A., Rubin, J., Pattabiraman, K.: Achecker: Statically detecting smart
contract access control vulnerabilities. In: ICSE (2023). https://doi.org/10.1109/
icse48619.2023.00087

16. Gibson, D., Igonor, A.: Managing Risk in Information Systems. Learning Inform-
ation Systems Security & Assurance, Jones & Bartlett, 3 edn. (2022)

17. GNSPS: Surya: A set of utilities for exploring solidity contracts (2019), https:
//github.com/Consensys/surya

https://ec.europa.eu/info/research-and-innovation/funding/funding-opportunities/funding-programmes-and-open-calls/horizon-europe/marie-sklodowska-curie-actions_en
https://next-generation-eu.europa.eu/index_en
https://doi.org/10.46298/lmcs-18(1:22)2022
https://doi.org/10.46298/lmcs-18(1:22)2022
https://doi.org/10.46298/lmcs-18(1:22)2022
https://doi.org/10.46298/lmcs-18(1:22)2022
https://ethereum.org/content/whitepaper/whitepaper-pdf/Ethereum_Whitepaper_-_Buterin_2014.pdf
https://ethereum.org/content/whitepaper/whitepaper-pdf/Ethereum_Whitepaper_-_Buterin_2014.pdf
https://doi.org/10.1007/978-3-030-32409-4_18
https://doi.org/10.1007/978-3-030-32409-4_18
https://doi.org/10.1007/978-3-030-32409-4_18
https://doi.org/10.1007/978-3-030-32409-4_18
https://doi.org/10.1145/3391195
https://doi.org/10.1145/3391195
https://coinmarketcap.com/
https://crypto.com/price
https://www.immunebytes.com/blog/list-of-largest-crypto-hacks-in-2024/
https://www.immunebytes.com/blog/list-of-largest-crypto-hacks-in-2024/
https://github.com/crytic/medusa
https://doi.org/10.1109/MCSE.2017.3421554
https://doi.org/10.1109/MCSE.2017.3421554
https://doi.org/10.1109/PRDC53464.2021.00013
https://doi.org/10.1109/PRDC53464.2021.00013
https://doi.org/10.1109/PRDC53464.2021.00013
https://doi.org/10.1109/PRDC53464.2021.00013
https://github.com/duaraghav8/Ethlint
https://doi.org/10.1145/3377811.3380364
https://doi.org/10.1145/3377811.3380364
https://doi.org/10.1109/WETSEB.2019.00008
https://doi.org/10.1109/WETSEB.2019.00008
https://doi.org/10.1145/3395363.3397385
https://doi.org/10.1145/3395363.3397385
https://doi.org/10.1109/icse48619.2023.00087
https://doi.org/10.1109/icse48619.2023.00087
https://doi.org/10.1109/icse48619.2023.00087
https://doi.org/10.1109/icse48619.2023.00087
https://github.com/Consensys/surya
https://github.com/Consensys/surya


18 Oss & Budde

18. Grieco, G., Song, W., Cygan, A., Feist, J., Groce, A.: Echidna: Effective, usable,
and fast fuzzing for smart contracts. SIGSOFT (2020). https://doi.org/10.1145/
3395363.3404366

19. Hu, T., Li, J., Storhaug, A., Li, B.: Why smart contracts reported as vulnerable
were not exploited? TechRxiv (2023). https://doi.org/10.36227/techrxiv.21953189.
v3, https://www.techrxiv.org/doi/full/10.36227/techrxiv.21953189.v1

20. Liu, Z., Luong, N.C., Wang, W., Niyato, D., Wang, P., Liang, Y.C., Kim, D.I.: A
survey on Blockchain: A game theoretical perspective. IEEE Access 7, 47615–47643
(2019). https://doi.org/10.1109/ACCESS.2019.2909924

21. Luu, L., Chu, D.H., Olickel, H., Saxena, P., Hobor, A.: Making smart contracts
smarter (2016). https://doi.org/10.1145/2976749.2978309

22. Nakamoto, S.: Bitcoin: A peer-to-peer electronic cash system (2008)
23. Oliva, G.A., Hassan, A.E., Jiang, Z.M.J.: An exploratory study of smart contracts

in the ethereum blockchain platform. Empir. Softw. Eng. 25(3), 1864–1904 (2020).
https://doi.org/10.1007/S10664-019-09796-5

24. Oss, T., Budde, C.E.: Vulnerability anti-patterns in Solidity: Detecti artifact
(experimental reproduction package) (2024). https://doi.org/10.6084/m9.figshare.
26121655, https://figshare.com/articles/software/26121655

25. Owasp smart contract top 10 (2023), https://owasp.org/
www-project-smart-contract-top-10/

26. Pasqua, M., Benini, A., Contro, F., Crosara, M., Dalla Preda, M., Ceccato, M.: En-
hancing ethereum smart-contracts static analysis by computing a precise control-
flow graph of ethereum bytecode. Journal of Systems and Software 200, 111653
(Jun 2023). https://doi.org/10.1016/j.jss.2023.111653

27. Perez, D., Livshits, B.: Smart contract vulnerabilities: Vulnerable does not imply
exploited. In: USENIX Security 21. pp. 1325–1341. USENIX Association (2021),
https://www.usenix.org/conference/usenixsecurity21/presentation/perez

28. Prana, G.A.A., Sharma, A., Shar, L.K., Foo, D., Santosa, A.E., Sharma, A., Lo,
D.: Out of sight, out of mind? how vulnerable dependencies affect open-source
projects. Empirical Software Engineering 26(4) (2021). https://doi.org/10.1007/
s10664-021-09959-3

29. Riczardo: Riczardo/solscan: Static solidity smart contracts scanner written in py-
thon, https://github.com/riczardo/solscan

30. Sharma, N., Sharma, S.: A survey of Mythril, a smart contract security analysis
tool for EVM bytecode. Indian Journal of Natural Sciences 13(75) (2022)

31. Solidity programming language (2024), https://docs.soliditylang.org/en
32. Sujeetc: Sujeetc/scrawld, https://github.com/sujeetc/ScrawlD
33. Szabo, N.: Formalizing and securing relationships on public networks. First Monday

2(9) (1997). https://doi.org/10.5210/fm.v2i9.548
34. Team, R.: Remix project: Jump into web3 (2022), https://remix-project.org/
35. Tikhomirov, S., Voskresenskaya, E., Ivanitskiy, I., Takhaviev, R., Marchenko, E.,

Alexandrov, Y.: Smartcheck: Static analysis of ethereum smart contracts. In: WET-
SEB. pp. 9–16. ACM (2018). https://doi.org/10.1145/3194113.3194115

36. Torres, C.F., Iannillo, A.K., Gervais, A., State, R.: Confuzzius: A data dependency-
aware hybrid fuzzer for smart contracts. In: EuroS&amp;P (2021). https://doi.org/
10.1109/eurosp51992.2021.00018

37. Torres, C.F., Schütte, J., State, R.: Osiris: Hunting for integer bugs in ethereum
smart contracts. In: ACSAC (2018). https://doi.org/10.1145/3274694.3274737

38. Wang, Y., He, J., Zhu, N., Yi, Y., Zhang, Q., Song, H., Xue, R.: Security enhance-
ment technologies for smart contracts in the blockchain: A survey. Trans Emerging
Tel Tech 32(12), 29 (2021). https://doi.org/https://doi.org/10.1002/ett.4341

https://doi.org/10.1145/3395363.3404366
https://doi.org/10.1145/3395363.3404366
https://doi.org/10.1145/3395363.3404366
https://doi.org/10.1145/3395363.3404366
https://doi.org/10.36227/techrxiv.21953189.v3
https://doi.org/10.36227/techrxiv.21953189.v3
https://doi.org/10.36227/techrxiv.21953189.v3
https://doi.org/10.36227/techrxiv.21953189.v3
https://www.techrxiv.org/doi/full/10.36227/techrxiv.21953189.v1
https://doi.org/10.1109/ACCESS.2019.2909924
https://doi.org/10.1109/ACCESS.2019.2909924
https://doi.org/10.1145/2976749.2978309
https://doi.org/10.1145/2976749.2978309
https://doi.org/10.1007/S10664-019-09796-5
https://doi.org/10.1007/S10664-019-09796-5
https://doi.org/10.6084/m9.figshare.26121655
https://doi.org/10.6084/m9.figshare.26121655
https://doi.org/10.6084/m9.figshare.26121655
https://doi.org/10.6084/m9.figshare.26121655
https://figshare.com/articles/software/26121655
https://owasp.org/www-project-smart-contract-top-10/
https://owasp.org/www-project-smart-contract-top-10/
https://doi.org/10.1016/j.jss.2023.111653
https://doi.org/10.1016/j.jss.2023.111653
https://www.usenix.org/conference/usenixsecurity21/presentation/perez
https://doi.org/10.1007/s10664-021-09959-3
https://doi.org/10.1007/s10664-021-09959-3
https://doi.org/10.1007/s10664-021-09959-3
https://doi.org/10.1007/s10664-021-09959-3
https://github.com/riczardo/solscan
https://docs.soliditylang.org/en
https://github.com/sujeetc/ScrawlD
https://doi.org/10.5210/fm.v2i9.548
https://doi.org/10.5210/fm.v2i9.548
https://remix-project.org/
https://doi.org/10.1145/3194113.3194115
https://doi.org/10.1145/3194113.3194115
https://doi.org/10.1109/eurosp51992.2021.00018
https://doi.org/10.1109/eurosp51992.2021.00018
https://doi.org/10.1109/eurosp51992.2021.00018
https://doi.org/10.1109/eurosp51992.2021.00018
https://doi.org/10.1145/3274694.3274737
https://doi.org/10.1145/3274694.3274737
https://doi.org/https://doi.org/10.1002/ett.4341
https://doi.org/https://doi.org/10.1002/ett.4341


Vulnerability anti-patterns in Solidity 19

39. Wood, G.: Ethereum: A secure decentralised generalised transaction ledger.
Ethereum project yellow paper 151, 1–32 (2014), https://ethereum.github.io/
yellowpaper/paper.pdf

40. Yaish, A., Tochner, S., Zohar, A.: Blockchain stretching & squeezing: Manipulating
time for your best interest. In: EC. pp. 65–88. ACM (2022). https://doi.org/10.
1145/3490486.3538250

41. Yu, R., Shu, J., Yan, D., Jia, X.: ReDetect: Reentrancy vulnerability detection in
smart contracts with high accuracy. In: MSN. pp. 412–419 (2021). https://doi.org/
10.1109/MSN53354.2021.00069

42. Zheng, Z., Zhang, N., Su, J., Zhong, Z., Ye, M., Chen, J.: Turn the Rudder: A
beacon of reentrancy detection for smart contracts on Ethereum. In: ICSE. pp.
295–306. IEEE (2023). https://doi.org/10.1109/icse48619.2023.00036

43. Zou, W., Lo, D., Kochhar, P.S., Le, X.B.D., Xia, X., Feng, Y., Chen, Z., Xu, B.:
Smart contract development: Challenges and opportunities. IEEE TSE 47(10),
2084–2106 (2021). https://doi.org/10.1109/TSE.2019.2942301

A The Solidity language

1 // SPDX-License-Identifier: MIT
2 pragma solidity ^0.8.0;
3 contract CollectMoney {
4 address payable public owner;
5 constructor() {
6 owner = payable(msg.sender);
7 }
8 modifier onlyOwner() {
9 require(msg.sender == owner, "Not the owner");

10 _;
11 }
12 function withdraw(uint amount) public onlyOwner {
13 if(amount <= address(this).balance){
14 _sendFunds(owner, amount);
15 }
16 }
17 function _sendFunds(address payable recipient, uint amount) private {
18 recipient.send(amount);
19 }
20 function getBalance() public view returns (uint) {
21 return address(this).balance;
22 }
23 }

Code 2: Solidity code of an example contract

Code 2 shows the syntax of a Solidity smart contract. Its structure resembles
a class in object-oriented programming, where the main construct (a contract)
defines variables and functions and can be instantiated. Local variables can also
be defined internally to a function. Functions implement the interface by which
external entities can interact with the contract (public functions), as well as
internal functionality (private functions).

Solidity supports elementary datatypes such as Booleans, integers such as
int8 and uint256, and strings, as well as composite types such as arrays and

https://ethereum.github.io/yellowpaper/paper.pdf
https://ethereum.github.io/yellowpaper/paper.pdf
https://doi.org/10.1145/3490486.3538250
https://doi.org/10.1145/3490486.3538250
https://doi.org/10.1145/3490486.3538250
https://doi.org/10.1145/3490486.3538250
https://doi.org/10.1109/MSN53354.2021.00069
https://doi.org/10.1109/MSN53354.2021.00069
https://doi.org/10.1109/MSN53354.2021.00069
https://doi.org/10.1109/MSN53354.2021.00069
https://doi.org/10.1109/icse48619.2023.00036
https://doi.org/10.1109/icse48619.2023.00036
https://doi.org/10.1109/TSE.2019.2942301
https://doi.org/10.1109/TSE.2019.2942301


20 Oss & Budde

struct. For control flow the usual branch and loop constructs are available (if,
while), and recursive calls are possible.

The global namespace, and certain predefined types, expose variables and
functions to read data from the blockchain, the evm global state, or to in-
teract with other contracts/accounts. Relevant examples include the functions
call, send, and transfer—mostly used to transfer eth cryptocurrency—and
the variables block.number and .timestamp.

Moreover, a modifier struct in Solidity can implement assertions (require)
such as the valid caller of a function; and a logging mechanism can be used to
emit events, i.e. notifications that are recorded on the blockchain. While they
are useful for tracking the execution and behavior of the contract, they cannot
by themselves modify the contract’s state.

B Top-10 vulnerabilities in Solidity

The Open Worldwide Application Security Project (owasp) maintains a rank-
ing of the ten most pervasive and exploited vulnerabilities in smart contracts
[25]. The list is broadly construed, including e.g. faulty code logic and mining
attacks that are oblivious of the code in a smart contract.

From those vulnerabilities, Sec. 2.1 selects three that can be (partially) iden-
tified via code patterns, thus falling in the scope of this work. For completeness,
here we present a brief overview of the entire top-10 ranking updated to 2023:

1. Reentrancy Attacks: A malicious contract exploits a loophole in the vic-
tim contract to repeatedly withdraw funds. Mainly caused by failing to
promptly verify the exploiter’s updated balance.

2. Integer Overflow and Underflow: Each integer type has a range, so each
integer variable can only store numbers within the range of its data types.
If this range is exceeded, it will cause an overflow or an underflow.

3. Timestamp Dependence: Dependence on the block timestamp value to
carry out an operation. Since the timestamp value is generated by the node
executing the smart contract, it becomes susceptible to manipulation and
vulnerable to attacks.

4. Access Control Vulnerabilities: A type of security flaw that allows users
without permission to interact with and alter data or functions in a smart
contract.

5. Front-running Attacks: The gas price of new transactions are appropri-
ately adjusted for impacting the ordering of transactions waiting in the pool
to be mined as blocks.

6. Denial of Service (DoS) Attacks: A DoS attack involves exploiting vul-
nerabilities to exhaust resources such as gas, CPU cycles, or storage, render-
ing the contract unusable.

7. Logic Errors: If a smart contract is poorly coded, it may contain logic er-
rors that lead to unintended behavior. This could range from incorrect cal-
culations to faulty conditional statements, or even exposed administrative
functions.



Vulnerability anti-patterns in Solidity 21

8. Insecure Randomness: Use of an insecure randomness source that allows
attackers to manipulate or predict the generated number in order to gain
benefits illegally.

9. Gas Limit Vulnerabilities: When attackers exploit the gas limits to dis-
rupt the normal functioning of the blockchain network. They can design
transactions or smart contracts that consume an excessive amount of gas
intentionally.

10. Unchecked External Calls: The call(), send(), callcode(), and delegatecall()
functions return a Boolean that states the success or failure of the opera-
tion. If the return value of the call is not checked, program execution could
continue by assuming its success, even if call failed.

C Selection of eligible tools for this study

After an initial filter of ssc security analysis tools by the criteria defined in
Sec. 4—see Tables 3 and 4—a total of 13 tools were found eligible as usable
“off-the-shelf”. We then assessed those tools in more depth, to select those that
are applicable to the dataset of vulnerable ssc presented in Sec. 3.

Table 7 presents the results of this second evaluation, where three tools were
found to be adequate for our needs in order to perform balanced and comprehens-
ive tests, namely Slither, Mythril, and Remix Analysis. In the case of rejected
tools, the rightmost column describes the motivations that led to this choice.

D Vulnerability anti-patterns by example

Sec. 5 introduced code patterns which, when flagged by a tool as a potential
security vulnerability, suggest that it is in fact a false-positive. Those patterns
were discovered in part by reading the literature, but also by analysing the
security analyses results of the tools used in our experimentation. Here we detail
these results, to give further insight into the reasons why the proposed patterns
are indicative of fp, with examples on Solidity smart contracts included in our
curated dataset [24].

D.1 Unchecked Return Value

Static checkers such as Slither and Remix flag all instances where the return
value of an invocation to send, call, callcode, or delegatecall is not used in
a guard or captured by a variable. This simplistic syntactic match produces a
significant amount of fp, as an unchecked value does not imply an insecure
contract logic, and this can be checked statically in many cases as we show next.

Note that experiments with Mythril exhibited better precision—although
this depends strongly on the logic and size of the contract—possibly thanks to
its taint-analysis capabilities. The price to pay when using Mythtil was a much-
longer runtime, several minutes per contract, in some cases even an hour or



22 Oss & Budde

Table 7: foss tools for ssc security that match our needs
Tool Description Match Main reason

Oyente
[21]

Symbolic execution. Parses
source- and byte-code. No

The latest supported version is solc 0.4.19,
which means really limited in terms of Solid-
ity versions supported.

Mythril
[30]

Symbolic execution, smt solving,
and taint analysis. Severity rat-
ing.

Yes
Swift installation through Docker image, and
vulnerabilities match our interest set. Covers
all versions of Solidity (project maintained).

Osiris
[37]

Symbolic execution and taint
analysis (leverages Oyente). No Being based on Oyente it has the same prob-

lems as the latter.

Slither
[13]

Static checker and taint analysis,
via the SlithIR intermediate
representation.

Yes
Super easy installation and use, and vulner-
abilities math our interest set. Covers all
versions of Solidity (project maintained).

Smart
Check

[35]

Static checker via an XML-based
intermediate representation. No

Deprecated since 2020, failing for Solidity
v0.6.0 and above, which reduces severely the
test set of smart contracts.

Remix
[34]

Static checker (Remix Analysis
is a plugin of Remix, the official
ide of Solidity).

Yes

Most functional out-of-the-box tool found,
offered via package managers and even via
an online version. Vulnerabilities match our
interest set. Covers all versions of Solidity
(project maintained).

Echidna
[18]

Fuzzer to detect violations in
assertions and custom properties. No

Not exactly a vulnerability detector, it does
not deal with any of the vulnerabilities of
interest to us.

ConFuzzius
[36]

Hybrid fuzzing, a combination of
symbolic execution and fuzzing. No

Complex command to launch analysis (many
arguments). Returns errors for newer ver-
sions of Solidity.

Solscan
[29]

Static checker based on regular
expressions and contextual ana-
lysis.

No

For many contracts return errors sim-
ilar to "An error occurred while checking
NAME_VULN. This vulnerability class was
NOT checked." for some vulnerabilities (in-
compatible Solidity versions?).

Ethlint
[11]

Static checker with a set of core
rules for linting code. No Deprecated since 2019, failing for newer

Solidity versions. Does not cover Reentrancy.

Medusa
[8]

Go-ethereum-based fuzzer in-
spired by Echidna. No Being based on Oyente it has the same prob-

lems as the latter.

AChecker
[15]

Static data-flow and symbolic-
based analysis. No

Focus on Access Control Vulnerabilities,
Does not cover the three vulnerabilities of
our interest.

EtherSolve
[26]

Static checker, based on symbolic
execution of the EVM operands
stack.

No It does not cover URV and TD. Analyzes
only EVM bytecode, no Solidity source code.



Vulnerability anti-patterns in Solidity 23

1 contract Escrow {
2 address buyer;
3 address seller;
4 address arbitrator;
5 function Escrow() payable {
6 seller = 0x5ed8cee6b63b1c6afce3ad7c92f4fd7e1b8fad9f;
7 buyer = msg.sender;
8 arbitrator = 0xabad6ec946eff02b22e4050b3209da87380b3cbd;
9 }

10 function finalize() {
11 if (msg.sender == buyer || msg.sender == arbitrator)
12 seller.send(this.balance);
13 }
14 function refund() {
15 if (msg.sender == seller || msg.sender == arbitrator)
16 buyer.send(this.balance);
17 }
18 }

Code 3: Solidity smart contract Escrow

more. This makes it hard to embed in production environments that implement
e.g. agile code development.

Regarding our fp code patterns for the urv vulnerability, Code 3 displays
two examples. More in detail, an Unchecked Return Value attack attempts to
exploits the continuation of a contract execution that assumed (without check-
ing) a successful end of instruction. But in lines 12 and 16 of Code 3 nothing
can continue executing, for the simple fact that there are no further instructions.
Note that, in spite of this, all tools mark the contract as vulnerable.

For another example we note that line 13 in Code 4 matches the third pattern
discussed in Sec. 5.1. Because kashout is initialised as the msg.sender address,
which is the caller of the function. Therefore, for attackers it makes no sense to
have the crypto transfer to themselves fail if the following part of the contract will
be executed regardless of the outcome of the transfer. This is in close connection
to our definition of security vulnerability, that requires that A ∩ V = ∅.

1 contract EasyInvest10 {
2 address owner;
3 constructor() {
4 owner = msg.sender;
5 }
6 mapping (address => uint256) invested;
7 mapping (address => uint256) atBlock;
8 function() external payable {
9 owner.send(msg.value/5);

10 if (invested[msg.sender] != 0){
11 address kashout = msg.sender;
12 uint256 getout = invested[msg.sender]*10/100*(block.number-atBlock[msg.sender])

/5900;
13 kashout.send(getout);
14 }
15 atBlock[msg.sender] = block.number;
16 invested[msg.sender] += msg.value;
17 }
18 }

Code 4: Solidity smart contract EasyInvest10

https://etherscan.io/address/0x073e957bc883693f15ecb14bfced3e8ffc8654c5#code
https://etherscan.io/address/0x0744a686c17480b457a4fbb743195bf2815ca2b8#code


24 Oss & Budde

D.2 Reentrancy

For reentrancy vulnerabilities, both Slither and Remix exhibit a similar opera-
tional approach, necessitating the presence of a specific condition for vulnerab-
ilities of this type to be identified. Our experiments match this with the modi-
fication of the contract state after an invocation, beyond the contract’s scope,
to call or after a direct call to an external contract function, usually made by
conversion of an address variable to an abstract contract type defined in the
solidity file (abstr_contr(adr).funct).

There are two ways the state change can happen according to the criteria
of these tools: either by emitting an event, or altering the value of some state
variables. However, the documentation specifies that events emission are logging
primitives that cannot modify the state [31], rendering all first cases moot. In
turn, and as pointed out in [42], altering a state variable after such instructions
is necessary but not sufficient to make the contract vulnerable to reentrancy
attacks. This provides another simple false positive check, which however cannot
be directly used to spot true positives.

Take as an example Code 5, where line 15 is a true state modification, pre-
cisely of the balance of a potential attacker, and it is executed after an invocation
to call two lines earlier. Notwithstanding, this function is not vulnerable to reen-
trancy either, by virtue of the onlyOwner modifier, which asserts (via require)
that only the owner of the contract account is able to execute the function.

1 contract Ownable is Context {
2 . . .
3 modifier onlyOwner() {
4 require(_owner == _msgSender(), "Ownable: caller is not the owner");
5 _;
6 }
7 }
8 . . .
9 contract NBUNIERC20 is Context, INBUNIERC20, Ownable {

10 . . .
11 function emergencyDrain24hAfterLiquidityGenerationEventIsDone() public onlyOwner {
12 require(contractStartTimestamp.add(4 days) < block.timestamp, "Liquidity generation

grace period still ongoing"); // About 24h after liquidity generation happens
13 (bool success, ) = msg.sender.call.value(address(this).balance)("");
14 require(success, "Transfer failed.");
15 _balances[msg.sender] = _balances[address(this)];
16 _balances[address(this)] = 0;
17 }
18 . . .
19 }

Code 5: Solidity code snippet of the Decore contract

Finally we note that here, and as with unchecked return values, Mythril
proved to be the most specific tool in our experimentation, at the cost of longer
runtimes. In contrast, our experiments with Remix and Slither resulted in 59%
and 66% false positive rates.

https://etherscan.io/address/0xb944B46Bbd4ccca90c962EF225e2804E46691cCF#code


Vulnerability anti-patterns in Solidity 25

D.3 Timestamp Dependence

For td, Remix reports every use of block.timestamp and/or now as a potential
vulnerability without apparent further analysis. In contrast, the other tools seem
to consider the use—direct or via variable declaration—of the timestamp as
part of a Boolean condition in a branching, looping guard, or boolean variable
definition. Slither is conservative, marking any such occurrence as a vulnerable
instruction. Mythril performs stricter checks, and in fact our experiments in
Sec. 6.2 show a number of false negatives, where it fails to recognise a potentially
vulnerable use of the timestamp.

For an example of the pattern introduced in Sec. 5.3 we draw attention to
line 6 in Code 6, where prtime[owner] is subtracted from now (a syntax sugar
for block.timestamp), and then verified that the result is greater than or equal
to 86400. Therefore, it is checked that the timestamp of the block is at least
one day later than the time instant (timestamp of a previous block where the
contract was executed defining that variable) saved in prtime[owner]. A 15-
seconds manipulation in this scenario would not be relevant, and thus flagging
this use of now as vulnerable is a fp.

1 contract FifteenPlus {
2 . . .
3 mapping (address => uint256) timestamp;
4 . . .
5 function() external payable {
6 if((now-prtime[owner]) >= 86400){
7 owner.transfer(ths.balance / 100);
8 prtime[owner] = now;
9 }

10 . . .
11 }
12 }

Code 6: Solidity code snippet of the FifteenPlus contract

We also highlight how td attacks are generally less severe than ree or urv.
Technically, value manipulations in this context are limited to few units/second,
so even if the manipulable value (modulo arithmetic operations) is taken as a
loss, that loss is bounded, in contrast to the other two vulnerabilities studied.
Nonetheless, our definition of vulnerability does include as tp any manipulation
of cryptocurrency that an attacker could exploit via td exploits.

E Detailed results per contract

Sec. 6.2 presented results of our experiments, aggregated for all contracts in our
dataset for each vulnerability. Here, Figs. 2a to 2c show the outcomes for each
individual contract. The number on top of the columns represents the number of
false positives, produced by the tool considered for the specific contract analyzed,
that Detecti correctly recognized as such.

https://etherscan.io/address/0xcfd2047eb61412e9b8de511dc2087e07003829ee#code


26
O

ss
&

B
udde

(a) Contracts potentially vulnerable to Unchecked Return Value

(b) Contracts potentially vulnerable to Reentrancy

(c) Contracts potentially vulnerable to Timestamp Dependence

Figure 2: Individual results of our experiments, per contract


	Vulnerability anti-patterns in Solidity: Increasing smart contracts security by reducing false alarms

